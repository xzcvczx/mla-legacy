/**************************************************************
 * HTTPPrint.h
 * Provides callback headers and resolution for user's custom
 * HTTP Application.
 *
 * This file is automatically generated by the MPFS Utility
 * ALL MODIFICATIONS WILL BE OVERWRITTEN BY THE MPFS GENERATOR
 **************************************************************/

#ifndef __HTTPPRINT_H
#define __HTTPPRINT_H

#include "TCPIP Stack/TCPIP.h"
#include "MainDemo.h"
#include "ginsu.h"

#if defined(STACK_USE_HTTP2_SERVER)

extern HTTP_CONN curHTTP;
extern HTTP_STUB httpStubs[MAX_HTTP_CONNECTIONS];
extern BYTE curHTTPID;

void HTTPPrint(DWORD callbackID);
void HTTPPrint_manu(void);
void HTTPPrint_model(void);
void HTTPPrint_devid(void);
void HTTPPrint_hash1(void);
void HTTPPrint_hash2(void);
void HTTPPrint_hash3(void);
void HTTPPrint_authtoken(void);
void HTTPPrint_authpath(void);
void HTTPPrint_status(void);
void HTTPPrint_num_sensor(void);
void HTTPPrint_cap_int(void);
void HTTPPrint_send_int(void);

void HTTPPrint(DWORD callbackID)
{
	switch(callbackID)
	{
        case 0x00000002:
			HTTPIncFile((ROM BYTE*)"footer.inc");
			break;
        case 0x00000033:
			HTTPIncFile((ROM BYTE*)"header.inc");
			break;
        case 0x0000004a:
			HTTPPrint_manu();
			break;
        case 0x0000004b:
			HTTPPrint_model();
			break;
        case 0x0000004c:
			HTTPPrint_devid();
			break;
        case 0x0000004d:
			HTTPPrint_hash1();
			break;
        case 0x0000004e:
			HTTPPrint_hash2();
			break;
        case 0x0000004f:
			HTTPPrint_hash3();
			break;
        case 0x00000050:
			HTTPPrint_authtoken();
			break;
        case 0x00000051:
			HTTPPrint_authpath();
			break;
        case 0x00000052:
			HTTPPrint_status();
			break;
        case 0x00000053:
			HTTPPrint_num_sensor();
			break;
        case 0x00000054:
			HTTPPrint_cap_int();
			break;
        case 0x00000055:
			HTTPPrint_send_int();
			break;
		default:
			// Output notification for undefined values
			TCPPutROMArray(sktHTTP, (ROM BYTE*)"!DEF", 4);
	}

	return;
}

void HTTPPrint_(void)
{
	TCPPut(sktHTTP, '~');
	return;
}

void HTTPPrint_manu(void)
{
    WORD len;
    WORD len2;

    len = TCPIsPutReady (sktHTTP);
    len2 = strlen (DEVICE_MANUFACTURER);

    if (curHTTP.callbackPos == 0)
        curHTTP.callbackPos = len2;

    while (len && curHTTP.callbackPos)
    {
        len -= TCPPut(sktHTTP, *(DEVICE_MANUFACTURER + (len2 - curHTTP.callbackPos)));
        curHTTP.callbackPos--;
    }

	return;
}

void HTTPPrint_model(void)
{
    WORD len;
    WORD len2;

    len = TCPIsPutReady (sktHTTP);
    len2 = strlen (DEVICE_MODEL);

    if (curHTTP.callbackPos == 0)
        curHTTP.callbackPos = len2;

    while (len && curHTTP.callbackPos)
    {
        len -= TCPPut(sktHTTP, *(DEVICE_MODEL + (len2 - curHTTP.callbackPos)));
        curHTTP.callbackPos--;
    }
	return;
}

void HTTPPrint_devid(void)
{
    BYTE buffer[14];
    BYTE i;

    buffer[0] = 'm';
    for (i = 0; i < 6; i++)
    {
        buffer[i+i+1] = btohexa_high (AppConfig.MyMACAddr.v[i]);
        buffer[i+i+2] = btohexa_low (AppConfig.MyMACAddr.v[i]);
    }

    buffer[13] = 0;

    // You can put up to 16 chars at a time
	TCPPutString(sktHTTP, buffer);
	return;
}

void HTTPPrint_hash1(void)
{
    BYTE buffer[41];
    BYTE i;
    WORD len;

    len = TCPIsPutReady (sktHTTP);

    if (curHTTP.callbackPos == 0)
        curHTTP.callbackPos = 40;

    for (i = 0; i < 20; i++)
    {
        buffer[i+i] = btohexa_high (gPowerMeterPreferences.pKeyHashes[0][i]);
        buffer[i+i+1] = btohexa_low (gPowerMeterPreferences.pKeyHashes[0][i]);
    }

    buffer[40] = 0;

    while (len && curHTTP.callbackPos)
    {
        len -= TCPPut(sktHTTP, buffer[40 - curHTTP.callbackPos]);
        curHTTP.callbackPos--;
    }
}

void HTTPPrint_hash2(void)
{
    BYTE buffer[41];
    BYTE i;
    WORD len;

    len = TCPIsPutReady (sktHTTP);

    if (curHTTP.callbackPos == 0)
        curHTTP.callbackPos = 40;

    for (i = 0; i < 20; i++)
    {
        buffer[i+i] = btohexa_high (gPowerMeterPreferences.pKeyHashes[1][i]);
        buffer[i+i+1] = btohexa_low (gPowerMeterPreferences.pKeyHashes[1][i]);
    }

    buffer[40] = 0;

    while (len && curHTTP.callbackPos)
    {
        len -= TCPPut(sktHTTP, buffer[40 - curHTTP.callbackPos]);
        curHTTP.callbackPos--;
    }
}

void HTTPPrint_hash3(void)
{
    BYTE buffer[41];
    BYTE i;
    WORD len;

    len = TCPIsPutReady (sktHTTP);

    if (curHTTP.callbackPos == 0)
        curHTTP.callbackPos = 40;

    for (i = 0; i < 20; i++)
    {
        buffer[i+i] = btohexa_high (gPowerMeterPreferences.pKeyHashes[2][i]);
        buffer[i+i+1] = btohexa_low (gPowerMeterPreferences.pKeyHashes[2][i]);
    }

    buffer[40] = 0;

    while (len && curHTTP.callbackPos)
    {
        len -= TCPPut(sktHTTP, buffer[40 - curHTTP.callbackPos]);
        curHTTP.callbackPos--;
    }
}

void HTTPPrint_authtoken(void)
{
    WORD len;
    WORD len2;

    len = TCPIsPutReady (sktHTTP);
    len2 = strlen ((char *)gPowerMeterPreferences.auth_token);

    if (curHTTP.callbackPos == 0)
        curHTTP.callbackPos = len2;

    while (len && curHTTP.callbackPos)
    {
        len -= TCPPut(sktHTTP, gPowerMeterPreferences.auth_token[len2 - curHTTP.callbackPos]);
        curHTTP.callbackPos--;
    }
}

void HTTPPrint_authpath(void)
{
    WORD len;
    WORD len2;

    len = TCPIsPutReady (sktHTTP);
    len2 = strlen ((char *)gPowerMeterPreferences.auth_path);

    if (curHTTP.callbackPos == 0)
        curHTTP.callbackPos = len2;

    while (len > 12 && curHTTP.callbackPos)
    {
        len -= TCPPut(sktHTTP, gPowerMeterPreferences.auth_path[len2 - curHTTP.callbackPos]);
        curHTTP.callbackPos--;
    }
}

void HTTPPrint_status(void)
{
    if (gPowerMeterPreferences.send_status)
        TCPPutROMString(sktHTTP, "TRUE");
    else
        TCPPutROMString(sktHTTP, "FALSE");
}

void HTTPPrint_num_sensor(void)
{
    TCPPut (sktHTTP, DEVICE_NUM_SENSORS + '0');
}

void HTTPPrint_cap_int(void)
{
    char buffer[16];

    sprintf((char *) buffer, "%ld", (long)gPowerMeterPreferences.cap_sec_interval);
    TCPPutString (sktHTTP, (BYTE *)buffer);
}

void HTTPPrint_send_int(void)
{
    char buffer[16];

    sprintf((char *) buffer, "%ld", (long)gPowerMeterPreferences.send_sec_interval);
    TCPPutString (sktHTTP, (BYTE *)buffer);
}

#endif

#endif
